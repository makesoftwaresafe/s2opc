/*
 * Licensed to Systerel under one or more contributor license
 * agreements. See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Systerel licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

IMPLEMENTATION
    address_space_i

REFINES
    address_space

SEES
    constants,
    constants_statuscodes_bs,
    service_write_decode_bs,
    service_response_cb_bs,
    write_value_pointer_bs,
    data_value_pointer_bs

IMPORTS
    address_space_bs,
    address_space_typing,
    address_space_local,
    gen_subscription_event_bs,
    user_authorization_bs

PROMOTES
    readall_AddressSpace_Node,
    get_NodeClass,
    get_BrowseName,
    get_DisplayName,
    is_transitive_subtype,
    is_valid_ReferenceTypeId,
    is_NodeId_equal,
    get_TypeDefinition,
    get_Reference_ReferenceType,
    get_Reference_TargetNode,
    get_Reference_IsForward,
    get_Node_RefIndexEnd,
    get_RefIndex_Reference,
    get_Value_StatusCode,
    read_AddressSpace_clear_value,
    read_AddressSpace_free_variant,
    is_local_service_treatment,
    set_local_service_treatment,
    get_user_authorization,
    get_Executable,
    get_InputArguments,
    get_conv_Variant_ValueRank,
    get_conv_Variant_Type,
    check_object_has_method,
    is_IndexRangeDefined

DEFINITIONS
    "definitions.def";
    "address_space.def";

    d_Type_IsVariableSubtype_NeedConv(dvNodeId, dvConcValueRank, varNodeId, varValueRank) ==
    /* A scalar ByteString is compatible with a 1 dimension Byte array */
    (dvNodeId = c_ByteString_Type_NodeId & dvConcValueRank = -1 &
     varNodeId = c_Byte_Type_NodeId & 1 |-> varValueRank : Type_IsIncludedValueRank)
    or /* A 1 dimension Byte array is compatible with a scalar ByteString */
    (dvNodeId = c_Byte_Type_NodeId & dvConcValueRank = 1 &
     varNodeId = c_ByteString_Type_NodeId & -1 |-> varValueRank : Type_IsIncludedValueRank);

    d_Type_IsVariableSubtype(dvNodeId, dvConcValueRank, varNodeId, varValueRank) ==
    ((dvNodeId = c_Null_Type_NodeId or dvNodeId = varNodeId or dvNodeId |-> varNodeId : Type_IsTransitiveSubtype) &
        dvConcValueRank |-> varValueRank : Type_IsIncludedValueRank)
    /* + Management of exceptional cases when typing a variable */
    or d_Type_IsVariableSubtype_NeedConv(dvNodeId, dvConcValueRank, varNodeId, varValueRank);

    d_VariantIndex_HasRange_Valid(dVal, idxRange, locale) ==
       ({FALSE |-> e_sc_bad_index_range_invalid,
          TRUE |-> {FALSE |-> e_sc_bad_index_range_no_data,
                    TRUE |-> {FALSE |-> e_sc_bad_invalid_argument,
                              TRUE |-> e_sc_ok
                             }(IsSupportedLocales_Variant(DataValue_Variant(dVal) |-> locale))
                   }(HasRange_VariantIndex(DataValue_Variant(dVal) |-> idxRange))
        }(IsValid_VariantIndex(DataValue_Variant(dVal) |-> idxRange)))
    ;

    d_treat_write (dVal, idxRange, nid, aid, user, locale) ==
       ({FALSE |-> e_sc_bad_node_id_unknown,
         TRUE  |-> {FALSE |-> e_sc_bad_not_writable,
                    TRUE  |-> {FALSE |-> e_sc_bad_type_mismatch,
                               TRUE |-> {FALSE |-> {FALSE |-> e_sc_bad_not_writable,
                                                    TRUE |-> {FALSE |-> e_sc_bad_user_access_denied,
                                                              TRUE |-> d_VariantIndex_HasRange_Valid(dVal, idxRange, locale)
                                                             }(bool(e_operation_type_write |-> nid |-> aid |-> user :
                                                                    s_AuthorizedOperations))
                                                   }(conv_AccessLevel_CurrentWrite(a_AccessLevel(a_NodeId~(nid)))),
                                         TRUE |-> d_VariantIndex_HasRange_Valid(dVal, idxRange, locale)
                                        }(bool(local_service_treatment = TRUE))
                              }(bool(d_Type_IsVariableSubtype
                                       (DataValue_LocalDataType(dVal), DataValue_ValueRank(dVal),
                                        a_DataType(a_NodeId~(nid)), a_ValueRank(a_NodeId~(nid)))))
                   }(bool(a_NodeClass(a_NodeId~(nid)) = e_ncl_Variable & aid = e_aid_Value))
        }(bool(nid : ran(a_NodeId))))


LOCAL_OPERATIONS
    bres <-- local_is_mandatory_attribute(p_ncl, p_aid) =
    PRE
        p_ncl : t_NodeClass_i &
        p_ncl : t_NodeClass &
        p_aid : t_AttributeId_i &
        p_aid : t_AttributeId
    THEN
        bres := bool(d_Mandatory_Attribute(p_ncl, p_aid))
    END
    ;

    /* Outer treat operation. Validates isvalid, validates user, records the write. */
    serviceStatusCode, prev_dataValue, node <-- treat_write_1(isvalid, status, p_user, p_locales, nid, aid, dataValue, index_range) =
    PRE
        isvalid : BOOL &
        status : t_StatusCode_i &
        p_user : t_user_i &
        p_user : t_user   &
        p_locales : t_LocaleIds_i &
        p_locales : t_LocaleIds   &
        nid : t_NodeId_i &
        aid : t_AttributeId_i &
        dataValue : t_DataValue_i &
        (isvalid = TRUE
            =>
         status = e_sc_ok & /* TODO: this is redundant with isvalid = TRUE */
         nid : t_NodeId &
         aid : t_AttributeId &
         dataValue : t_DataValue) &
        (isvalid = FALSE
            =>
         status : {e_sc_bad_attribute_id_invalid, e_sc_bad_index_range_invalid}) &
        a_NodeId : t_Node >-> t_NodeId &
        a_Value : t_Node +-> t_Variant &
        index_range : t_IndexRange_i
    THEN
        serviceStatusCode,
        prev_dataValue,
        node,
        a_Value,
        a_Value_StatusCode,
        a_Value_SourceTimestamp
        :(
            serviceStatusCode : t_StatusCode_i &
            serviceStatusCode : t_StatusCode &
            prev_dataValue : t_DataValue_i &
            node : t_Node_i &

            (isvalid = TRUE
            =>
                (serviceStatusCode = d_treat_write (dataValue, index_range, nid, aid, p_user, p_locales)
                or /* out of memory */
                serviceStatusCode = e_sc_bad_out_of_memory) &

                (serviceStatusCode = e_sc_ok
                =>
                    prev_dataValue : t_DataValue &
                    node = a_NodeId~(nid) &
                    DataValue_Variant(prev_dataValue) = a_Value$0(a_NodeId~(nid)) &
                    DataValue_StatusCode(prev_dataValue) = a_Value_StatusCode$0(a_NodeId~(nid)) &
                    DataValue_SourceTimestamp(prev_dataValue) = a_Value_SourceTimestamp$0(a_NodeId~(nid)) &

                    a_Value = a_Value$0 <+ {a_NodeId~(nid) |-> DataValue_Variant(dataValue)} &

                    (local_service_treatment = TRUE
                    =>
                        a_Value_StatusCode = a_Value_StatusCode$0
                                             <+ {a_NodeId~(nid) |-> DataValue_StatusCode(dataValue)} &
                        a_Value_SourceTimestamp = a_Value_SourceTimestamp$0
                                              <+ {a_NodeId~(nid) |-> DataValue_SourceTimestamp(dataValue)}
                    ) &
                    (local_service_treatment = FALSE
                    =>
                        (conv_AccessLevel_StatusWrite(a_AccessLevel(a_NodeId~(nid))) = TRUE
                        =>
                            a_Value_StatusCode = a_Value_StatusCode$0
                                <+ {a_NodeId~(nid) |-> DataValue_StatusCode(dataValue)}
                        ) &
                        (not(conv_AccessLevel_StatusWrite(a_AccessLevel(a_NodeId~(nid))) = TRUE)
                        =>
                            a_Value_StatusCode = a_Value_StatusCode$0) &

                        (conv_AccessLevel_TimestampWrite (a_AccessLevel(a_NodeId~(nid))) = TRUE
                        =>
                            a_Value_SourceTimestamp = a_Value_SourceTimestamp$0
                                <+ {a_NodeId~(nid) |-> DataValue_SourceTimestamp(dataValue)}
                        ) &
                        (not(conv_AccessLevel_TimestampWrite (a_AccessLevel(a_NodeId~(nid))) = TRUE)
                        =>
                            a_Value_SourceTimestamp = a_Value_SourceTimestamp$0)
                    )
                ) &
                (not(serviceStatusCode = e_sc_ok)
                =>
                    a_Value = a_Value$0 &
                    a_Value_StatusCode = a_Value_StatusCode$0 &
                    a_Value_SourceTimestamp = a_Value_SourceTimestamp$0
                )
            ) &
            (not(isvalid = TRUE)
            =>
                serviceStatusCode = status &
                a_Value = a_Value$0 &
                a_Value_StatusCode = a_Value_StatusCode$0 &
                a_Value_SourceTimestamp = a_Value_SourceTimestamp$0
            )
        )
    END
    ;

    /* Computes if DataValue has a compatible type or compatible subtype */
    btyp_ok, btyp_need_conv <-- is_variable_compat_type(p_dv_typ_nid, p_dv_vr, p_var_typ_nid, p_var_vr) =
    PRE
        p_dv_typ_nid : t_NodeId_i &
        p_dv_vr : t_ConcreteValueRank &
        p_var_typ_nid : t_NodeId_i &
        p_var_typ_nid : t_NodeId &
        p_var_vr : t_ValueRank
    THEN
        btyp_ok := bool(d_Type_IsVariableSubtype(p_dv_typ_nid, p_dv_vr, p_var_typ_nid, p_var_vr)) ||
        btyp_need_conv := bool(d_Type_IsVariableSubtype_NeedConv(p_dv_typ_nid, p_dv_vr, p_var_typ_nid, p_var_vr))
    END
    ;

    sc, val, val_sc, val_ts_src, val_ts_srv <-- read_AddressSpace_Attribute_value(p_user, p_locales, p_node, p_nid, p_aid, p_index_range) =
    PRE
        p_user : t_user_i &
        p_user : t_user   &
        p_locales  : t_LocaleIds_i &
        p_locales  : t_LocaleIds   &
        p_node : t_Node_i &
        p_node : t_Node &
        p_nid : t_NodeId_i &
        p_nid : t_NodeId &
        p_nid = a_NodeId(p_node) &
        p_aid : t_AttributeId_i &
        p_aid : t_AttributeId &
        p_index_range : t_IndexRange_i &

        /* We serve only these attributes */
        p_aid : {
            e_aid_AccessLevel,
            e_aid_BrowseName,
            e_aid_ContainsNoLoops,
            e_aid_DataType,
            e_aid_DisplayName,
            e_aid_EventNotifier,
            e_aid_Executable,
            e_aid_Historizing,
            e_aid_IsAbstract,
            e_aid_NodeClass,
            e_aid_NodeId,
            e_aid_Symmetric,
            e_aid_UserAccessLevel,
            e_aid_UserExecutable,
            e_aid_Value,
            e_aid_ValueRank,
            e_aid_ArrayDimensions
        } &

        (p_aid = e_aid_AccessLevel     => p_node : dom(a_AccessLevel))     &
        (p_aid = e_aid_BrowseName      => p_node : dom(a_BrowseName))      &
        (p_aid = e_aid_ContainsNoLoops => p_node : dom(a_ContainsNoLoops)) &
        (p_aid = e_aid_DataType        => p_node : dom(a_DataType))        &
        (p_aid = e_aid_DisplayName     => p_node : dom(a_DisplayName))     &
        (p_aid = e_aid_EventNotifier   => p_node : dom(a_EventNotifier))   &
        (p_aid = e_aid_Executable      => p_node : dom(a_Executable))      &
        (p_aid = e_aid_Historizing     => p_node : dom(a_Historizing))     &
        (p_aid = e_aid_IsAbstract      => p_node : dom(a_IsAbstract))      &
        (p_aid = e_aid_NodeClass       => p_node : dom(a_NodeClass))       &
        (p_aid = e_aid_NodeId          => p_node : dom(a_NodeId))          &
        (p_aid = e_aid_Symmetric       => p_node : dom(a_Symmetric))       &
        (p_aid = e_aid_UserAccessLevel => p_node : dom(a_UserAccessLevel)) &
        (p_aid = e_aid_UserExecutable  => p_node : dom(a_UserExecutable))  &
        (p_aid = e_aid_Value           => p_node : dom(a_Value))           &
        (p_aid = e_aid_ValueRank       => p_node : dom(a_ValueRank))       &
        (p_aid = e_aid_ArrayDimensions => p_node : dom(a_ArrayDimensions)) &

        /* For a Variable Value, the read must be authorized */
        (a_NodeClass(p_node) = e_ncl_Variable & p_aid = e_aid_Value =>
        (local_service_treatment = TRUE or
         (conv_AccessLevel_CurrentRead(a_AccessLevel(p_node)) = TRUE &
          e_operation_type_read |-> a_NodeId(p_node) |-> p_aid |-> p_user : s_AuthorizedOperations)))
    THEN
        sc,
        val,
        val_sc,
        val_ts_src,
        val_ts_srv
        :(sc : t_StatusCode_i &
          sc : t_StatusCode &
          val : t_Variant_i &
          val_sc : t_RawStatusCode &
          val_ts_src : t_Timestamp &
          val_ts_srv : t_Timestamp &
          /* Attribute is Value and IndexRange of Value is invalid */
          (p_aid = e_aid_Value &
           IsValid_VariantIndex(a_Value(p_node) |-> p_index_range) = FALSE
           =>
           val = c_Variant_indet &
           sc = e_sc_bad_index_range_invalid
          ) &
          /* Attribute is Value and IndexRange of Value does not contains data */
          (p_aid = e_aid_Value &
           IsValid_VariantIndex(a_Value(p_node) |-> p_index_range) = TRUE &
           HasRange_VariantIndex(a_Value(p_node) |-> p_index_range) = FALSE
           =>
           val = c_Variant_indet &
           sc = e_sc_bad_index_range_no_data
          ) &
          /* Attribute is not Value and IndexRange is defined but not expected */
          (p_aid /= e_aid_Value &
           IsRangeDefined(p_index_range) = TRUE
           =>
           val = c_Variant_indet &
           sc = e_sc_bad_index_range_no_data
          ) &
          /* Attribute is not Value or IndexRange of Value is valid and contains data*/
          ((p_aid /= e_aid_Value &
            IsRangeDefined(p_index_range) = FALSE) or
           (p_aid = e_aid_Value &
            IsValid_VariantIndex(a_Value(p_node) |-> p_index_range) = TRUE &
            HasRange_VariantIndex(a_Value(p_node) |-> p_index_range) = TRUE) =>
           sc = e_sc_ok or
           (val = c_Variant_indet &
            sc = e_sc_bad_out_of_memory)
          ) &

          /* In case of success set other output paramaters */
          (sc = e_sc_ok =>
            /* Set Variant value */
            (p_aid = e_aid_AccessLevel     => val = conv_AccessLevel_Variant(a_AccessLevel(p_node)))         &
            (p_aid = e_aid_BrowseName      => val = conv_QualifiedName_Variant(a_BrowseName(p_node)))        &
            (p_aid = e_aid_ContainsNoLoops => val = conv_Boolean_Variant(a_ContainsNoLoops(p_node)))         &
            (p_aid = e_aid_DataType        => val = conv_NodeId_Variant(a_DataType(p_node)))                 &
            (p_aid = e_aid_DisplayName     => val = conv_LocalizedText_Variant(a_DisplayName(p_node)))       &
            (p_aid = e_aid_EventNotifier   => val = conv_Byte_Variant(a_EventNotifier(p_node)))              &
            (p_aid = e_aid_Executable      => val = conv_Boolean_Variant(a_Executable(p_node)))              &
            (p_aid = e_aid_Historizing     => val = conv_Boolean_Variant(a_Historizing(p_node)))             &
            (p_aid = e_aid_IsAbstract      => val = conv_Boolean_Variant(a_IsAbstract(p_node)))              &
            (p_aid = e_aid_NodeClass       => val = conv_NodeClass_Variant(a_NodeClass(p_node)))             &
            (p_aid = e_aid_NodeId          => val = conv_NodeId_Variant(a_NodeId(p_node)))                   &
            (p_aid = e_aid_Symmetric       => val = conv_Boolean_Variant(a_Symmetric(p_node)))               &
            (p_aid = e_aid_UserAccessLevel => val = conv_AccessLevel_Variant(a_UserAccessLevel(p_node)))     &
            (p_aid = e_aid_UserExecutable  => val = conv_Boolean_Variant(a_UserExecutable(p_node)))          &
            (p_aid = e_aid_Value           => val = a_Value(p_node))                                         &
            (p_aid = e_aid_ValueRank       => val = conv_ValueRank_Variant(a_ValueRank(p_node)))             &
            (p_aid = e_aid_ArrayDimensions => val = conv_ArrayDimensions_Variant(a_ArrayDimensions(p_node))) &
            /* Fill status code and timestamp: Variable Value / NOT Variable Value */
            (a_NodeClass(p_node) = e_ncl_Variable & p_aid = e_aid_Value =>
             val_sc = a_Value_StatusCode(p_node) &
             val_ts_src = a_Value_SourceTimestamp(p_node) &
             val_ts_srv /= c_Timestamp_null /* Current date is returned as server date */) &
            (not (a_NodeClass(p_node) = e_ncl_Variable  & p_aid = e_aid_Value)  =>
             val_sc = c_RawStatusCode_Good &
             val_ts_src = c_Timestamp_null &
             val_ts_srv = c_Timestamp_null)
          ) &
          /* In case of failure set other output parameters */
          (not (sc = e_sc_ok) =>
             val = c_Variant_indet &
             /* The following two properties are not actually implemented
             val_sc = c_RawStatusCode_BadInvalidState &
             val_ts_src = c_Timestamp_null & */
             val_ts_srv = c_Timestamp_null)
        )
    END

OPERATIONS
    /* LOCAL_OPERATIONS */

    /* We only manage mandatory attributes */
    bres <-- local_is_mandatory_attribute(p_ncl, p_aid) =
    BEGIN
        /* Check attributes present in all node clasess */
        bres := bool(p_aid = e_aid_BrowseName or p_aid = e_aid_DisplayName or
                     p_aid = e_aid_NodeClass or p_aid = e_aid_NodeId);
        IF bres = FALSE THEN
            CASE p_ncl OF
                EITHER e_ncl_Variable THEN /* VARIABLE */
                    bres := bool(p_aid = e_aid_AccessLevel or p_aid = e_aid_DataType or
                        p_aid = e_aid_Historizing or p_aid = e_aid_UserAccessLevel or
                        p_aid = e_aid_Value or p_aid = e_aid_ValueRank or
                        p_aid = e_aid_ArrayDimensions)
                OR e_ncl_VariableType THEN /* VARIABLE TYPE */
                    bres := bool(p_aid = e_aid_DataType or p_aid = e_aid_IsAbstract or
                        p_aid = e_aid_ValueRank or p_aid = e_aid_ArrayDimensions)
                OR e_ncl_Object THEN /* OBJECT */
                    bres := bool(p_aid = e_aid_EventNotifier)
                OR e_ncl_ObjectType THEN /* OBJECT TYPE */
                    bres := bool(p_aid = e_aid_IsAbstract)
                OR e_ncl_ReferenceType THEN /* REFERENCE TYPE */
                    bres := bool(p_aid = e_aid_IsAbstract or p_aid = e_aid_Symmetric)
                OR e_ncl_DataType THEN /* DATA TYPE */
                    bres := bool(p_aid = e_aid_IsAbstract)
                OR e_ncl_Method THEN /* METHOD */
                    bres := bool(p_aid = e_aid_Executable or p_aid = e_aid_UserExecutable)
                OR e_ncl_View THEN /* VIEW */
                    bres := bool(p_aid = e_aid_EventNotifier or p_aid = e_aid_ContainsNoLoops)
                END
           END
        END
    END
    ;

    bres <-- is_mandatory_attribute(p_ncl, p_aid) =
    BEGIN
        bres <-- local_is_mandatory_attribute(p_ncl, p_aid)
    END
    ;

    p_status <-- treat_write_request_WriteValue (p_user, p_locales, p_wvi) =
    VAR
        l_aid,
        l_nid,
        l_dataValue,
        l_index_range,
        l_status1,
        l_prev_dataValue,
        l_node,
        l_access_lvl,
        l_access_read,
        l_prev_local_treatment,
        l_isvalid,
        l_local_treatment,
        l_wv,
        l_bres_wv_copy,
        l_wv_copy,
        l_new_sc,
        l_new_val,
        l_new_val_sc,
        l_new_val_ts_src,
        l_new_val_ts_srv
    IN
        l_isvalid, l_status1, l_nid, l_aid, l_dataValue, l_index_range <-- getall_WriteValue(p_wvi);
        /* Avoids the IFs with a local operation. */
        p_status, l_prev_dataValue, l_node <-- treat_write_1(l_isvalid, l_status1, p_user, p_locales, l_nid, l_aid, l_dataValue, l_index_range);
        l_new_val := c_Variant_indet;
        l_wv <-- getall_WriteValuePointer(p_wvi);
        /* If write succeeded, generates a data change event for subscriptions */
        IF p_status = e_sc_ok
        THEN
            /* Check access level: read access right <=> data change event for subscription */
            /*
            Justif: we do not generate data change event since we cannot return notification on non readable value.
            Moreover the access level is static and then the subscriber has already been notified on M.I. creation.
            */
            l_access_lvl <-- get_AccessLevel(l_node);
            l_access_read <-- is_t_access_level_currentRead(l_access_lvl);
            IF l_access_read = TRUE THEN
                /* Read updated value after write: necessary since write value item can be partial due to indexRange */
                /* Set local treatment since user can be anyone in subscription: avoid user right verification */
                l_prev_local_treatment <-- is_local_service_treatment;
                set_local_service_treatment(TRUE);
                l_new_sc, l_new_val, l_new_val_sc, l_new_val_ts_src, l_new_val_ts_srv
                <-- read_AddressSpace_Attribute_value(p_user, p_locales, l_node, l_nid, l_aid, c_IndexRange_indet);
                set_local_service_treatment(l_prev_local_treatment);
                IF l_new_sc = e_sc_ok THEN
                    gen_data_changed_event (l_nid, l_aid, l_prev_dataValue, l_new_val, l_new_val_sc, l_new_val_ts_src, l_new_val_ts_srv)
                ELSE
                    gen_data_changed_event_failed
                END
            END
        END;
        write_AddressSpace_free_dataValue (l_prev_dataValue);
        read_AddressSpace_free_variant (l_new_val);
        l_local_treatment <-- is_local_service_treatment;
        IF l_local_treatment = FALSE
        THEN
            l_bres_wv_copy, l_wv_copy <-- copy_write_value_pointer_content (l_wv);
            IF l_bres_wv_copy = TRUE THEN
                srv_write_notification (l_wv_copy, p_status)
            ELSE
                /* TODO: Generates an out of memory service result or error trace ? */
                skip
            END
        END
    END
    ;

    serviceStatusCode, prev_dataValue, node <-- treat_write_1(isvalid, status, p_user, p_locales, nid, aid, dataValue, index_range) =
    VAR
        l_isvalid,
        l_ncl,
        l_access_lvl,
        l_access_write,
        l_access_write_status,
        l_access_write_timestamp,
        l_authorized_write,
        l_compatible_type,
        l_compat_with_conv,
        l_var_datatype_nid,
        l_var_vr,
        l_dv_datatype_nid,
        l_dv_datatype_vr,
        l_local_treatment,
        l_variant,
        l_source_ts,
        l_raw_sc
    IN
        node := c_Node_indet;
        prev_dataValue := c_DataValue_indet;
        IF isvalid = TRUE THEN
            l_isvalid, node <-- readall_AddressSpace_Node(nid);
            IF l_isvalid = TRUE THEN
                l_ncl <-- get_NodeClass(node);
                IF aid = e_aid_Value & l_ncl = e_ncl_Variable THEN
                    l_var_datatype_nid <-- get_DataType(node);
                    l_var_vr <-- get_ValueRank(node);
                    l_dv_datatype_nid <-- get_conv_DataValue_LocalDataType(dataValue);
                    l_dv_datatype_vr <-- get_conv_DataValue_ValueRank(dataValue);
                    l_compatible_type, l_compat_with_conv
                      <-- is_variable_compat_type(l_dv_datatype_nid, l_dv_datatype_vr, l_var_datatype_nid, l_var_vr);
                    IF l_compatible_type = TRUE THEN
                        l_local_treatment <-- is_local_service_treatment;
                        l_variant <-- get_conv_DataValue_Variant(dataValue);
                        l_source_ts <-- get_conv_DataValue_SourceTimestamp(dataValue);
                        l_raw_sc <-- get_conv_DataValue_Status(dataValue);
                        IF l_local_treatment = TRUE THEN
                            /* No access authorization check for local treatment */
                            serviceStatusCode, prev_dataValue <-- set_Value(p_user, p_locales, node, l_variant, l_compat_with_conv, index_range);
                            IF serviceStatusCode = e_sc_ok THEN
                                set_Value_StatusCode(p_user, node, l_raw_sc);
                                set_Value_SourceTimestamp(p_user, node, l_source_ts)
                            END
                        ELSE
                            l_access_lvl <-- get_AccessLevel(node);
                            l_access_write <-- is_t_access_level_currentWrite(l_access_lvl);
                            l_access_write_status <-- is_t_access_level_statusWrite(l_access_lvl);
                            l_access_write_timestamp <-- is_t_access_level_timestampWrite(l_access_lvl);
                            IF l_access_write = TRUE THEN
                                /* Write authorization is for set_Value, and read authorization is for get_Value_StatusCode */
                                l_authorized_write <-- get_user_authorization(e_operation_type_write, nid, aid, p_user);
                                IF l_authorized_write = TRUE THEN
                                    serviceStatusCode, prev_dataValue
                                      <-- set_Value(p_user, p_locales, node, l_variant, l_compat_with_conv,  index_range);
                                    IF serviceStatusCode = e_sc_ok THEN
                                        /* Note: we set Status/Ts values if access level authorize it but we do not check
                                           client attempt to write Status/Ts whereas it is forbidden by access level.
                                           The reason is that we cannot differentiate a Good status (0) from no status
                                           or minimumTs (0) from no Ts.
                                           See mantis issue 3504, this has been solved since spec 1.04 (part 3 table 40)
                                           by always accepting to write 0 value if access level unset for Status/Ts.
                                           For other values if access level unset for Status/Ts,
                                           returns Bad_NotWritable since access level does not authorize it (part 4 table 178).
                                        */
                                        IF l_access_write_status = TRUE THEN
                                            set_Value_StatusCode(p_user, node, l_raw_sc)
                                        END;
                                        IF l_access_write_timestamp = TRUE THEN
                                            set_Value_SourceTimestamp(p_user, node, l_source_ts)
                                        END
                                    END
                                ELSE
                                    serviceStatusCode := e_sc_bad_user_access_denied
                                END
                            ELSE
                                serviceStatusCode := e_sc_bad_not_writable
                            END
                        END
                    ELSE
                        serviceStatusCode := e_sc_bad_type_mismatch
                    END
                ELSE
                    serviceStatusCode := e_sc_bad_not_writable
                END
            ELSE
                serviceStatusCode := e_sc_bad_node_id_unknown
            END
        ELSE
            serviceStatusCode := status
        END
    END
    ;

    btyp_ok, btyp_need_conv <-- is_variable_compat_type(p_dv_typ_nid, p_dv_vr, p_var_typ_nid, p_var_vr) =
    VAR
        l_node_ids_eq,
        l_dv_is_null_type,
        l_dv_is_sub_typ,
        l_dv_is_sub_typ_or_compat,
        l_dv_is_byte_type,
        l_dv_is_bytestring_type,
        l_var_is_byte_type,
        l_var_is_bytestring_type,
        l_var_is_scalar_vr,
        l_var_is_one_dim_vr,
        l_typ_is_ok,
        l_typ_need_conv,
        l_value_rank_is_ok
    IN
        l_typ_is_ok := FALSE;
        l_typ_need_conv := FALSE;
        l_value_rank_is_ok := FALSE;
        IF p_dv_typ_nid /= c_NodeId_indet THEN
            l_node_ids_eq <-- is_NodeId_equal(p_dv_typ_nid, p_var_typ_nid);
            l_dv_is_null_type <-- is_NodeId_equal(p_dv_typ_nid, c_Null_Type_NodeId);
            l_value_rank_is_ok <-- is_included_ValueRank(p_dv_vr, p_var_vr);
            IF l_node_ids_eq = TRUE THEN
                l_typ_is_ok := TRUE
            ELSIF l_dv_is_null_type = TRUE THEN
                l_typ_is_ok := TRUE
            ELSE
                l_dv_is_sub_typ <-- is_transitive_subtype(p_dv_typ_nid, p_var_typ_nid);
                l_dv_is_sub_typ_or_compat <-- is_transitive_subtype_or_compatible_simple_type_or_enumeration(l_dv_is_sub_typ, p_dv_typ_nid, p_var_typ_nid);
                IF l_dv_is_sub_typ_or_compat = TRUE THEN
                    l_typ_is_ok := TRUE
                ELSE
                    l_dv_is_bytestring_type <-- is_NodeId_equal(p_dv_typ_nid, c_ByteString_Type_NodeId);
                    l_dv_is_byte_type <-- is_NodeId_equal(p_dv_typ_nid, c_Byte_Type_NodeId);
                    l_var_is_bytestring_type <-- is_NodeId_equal(p_var_typ_nid, c_ByteString_Type_NodeId);
                    l_var_is_byte_type <-- is_NodeId_equal(p_var_typ_nid, c_Byte_Type_NodeId);
                    l_var_is_scalar_vr <-- is_included_ValueRank(-1, p_var_vr);
                    l_var_is_one_dim_vr <-- is_included_ValueRank(1, p_var_vr);
                    IF l_dv_is_bytestring_type = TRUE & p_dv_vr = -1 &
                        l_var_is_byte_type = TRUE & l_var_is_one_dim_vr = TRUE
                    THEN
                        /* New DataValue is ByteString and Variable accepts Byte[]: compatiblity with conversion */
                        l_typ_is_ok := TRUE;
                        l_typ_need_conv := TRUE;
                        l_value_rank_is_ok := TRUE
                    ELSIF l_dv_is_byte_type = TRUE & p_dv_vr = 1 &
                        l_var_is_bytestring_type = TRUE & l_var_is_scalar_vr = TRUE
                    THEN
                        /* New DataValue is Byte[] and Variable accepts ByteString: compatiblity with conversion */
                        l_typ_is_ok := TRUE;
                        l_typ_need_conv := TRUE;
                        l_value_rank_is_ok := TRUE
                    END
                END
            END
        END;
        btyp_ok := bool(l_typ_is_ok = TRUE & l_value_rank_is_ok = TRUE);
        btyp_need_conv := l_typ_need_conv
    END
    ;

    sc, val, val_sc, val_ts_src, val_ts_srv <-- read_AddressSpace_Attribute_value(p_user, p_locales, p_node, p_nid, p_aid, p_index_range) =
    VAR
        l_user_read_auth,
        l_user_write_auth,
        l_is_range_defined,
        l_user_executable_auth
    IN
        sc := e_sc_ok;
        val_sc <-- get_const_RawStatusCode_Good;
        val := c_Variant_indet;
        /* Retrieve current timestamp as default value */
        val_ts_srv <-- get_CurrentTimestamp;
        val_ts_src := c_Timestamp_null;
        l_is_range_defined <-- is_IndexRangeDefined(p_index_range);
        IF p_aid /= e_aid_Value & l_is_range_defined = TRUE THEN
            sc := e_sc_bad_index_range_no_data
        ELSE
            CASE p_aid OF
                EITHER e_aid_AccessLevel THEN
                    sc, val <-- read_AddressSpace_AccessLevel_value(p_node)
                OR e_aid_BrowseName THEN
                    sc, val <-- read_AddressSpace_BrowseName_value(p_node)
                OR e_aid_ContainsNoLoops THEN
                    sc, val <-- read_AddressSpace_ContainsNoLoops_value(p_node)
                OR e_aid_DataType THEN
                    sc, val <-- read_AddressSpace_DataType_value(p_node)
                OR e_aid_DisplayName THEN
                    sc, val <-- read_AddressSpace_DisplayName_value(p_locales, p_node)
                OR e_aid_EventNotifier THEN
                    sc, val <-- read_AddressSpace_EventNotifier_value(p_node)
                OR e_aid_Executable THEN
                    sc, val <-- read_AddressSpace_Executable_value(p_node)
                OR e_aid_Historizing THEN
                    sc, val <-- read_AddressSpace_Historizing_value(p_node)
                OR e_aid_IsAbstract THEN
                    sc, val <-- read_AddressSpace_IsAbstract_value(p_node)
                OR e_aid_NodeClass THEN
                    sc, val <-- read_AddressSpace_NodeClass_value(p_node)
                OR e_aid_NodeId THEN
                    sc, val <-- read_AddressSpace_NodeId_value(p_node)
                OR e_aid_Symmetric THEN
                    sc, val <-- read_AddressSpace_Symmetric_value(p_node)
                OR e_aid_UserAccessLevel THEN
                    l_user_read_auth <-- get_user_authorization(e_operation_type_read, p_nid, e_aid_Value, p_user);
                    l_user_write_auth <-- get_user_authorization(e_operation_type_write, p_nid, e_aid_Value, p_user);
                    sc, val <-- read_AddressSpace_UserAccessLevel_value(p_node, l_user_read_auth, l_user_write_auth)
                OR e_aid_UserExecutable THEN
                    l_user_executable_auth <-- get_user_authorization(e_operation_type_executable, p_nid, e_aid_Executable, p_user);
                    sc, val <-- read_AddressSpace_UserExecutable_value(p_node, l_user_executable_auth)
                OR e_aid_Value THEN
                    sc, val, val_sc, val_ts_src <-- read_AddressSpace_Value_value(p_locales, p_node, p_index_range)
                OR e_aid_ValueRank THEN
                    sc, val <-- read_AddressSpace_ValueRank_value(p_node)
                OR e_aid_ArrayDimensions THEN
                    sc, val <-- read_AddressSpace_ArrayDimensions_value(p_node)
                END
            END
        END
    END
    ;


    /* END LOCAL_OPERATIONS */

    sc, val, val_sc, val_ts_src, val_ts_srv <-- read_Node_Attribute(p_user, p_locales, p_node, p_nid, p_aid, p_index_range) =
    VAR
        l_is_mandatory_attribute,
        l_ncl,
        l_is_local_read,
        l_access_lvl,
        l_access_read,
        l_user_auth
    IN
        sc := e_sc_bad_attribute_id_invalid;
        val_sc <-- get_const_RawStatusCode_BadInvalidState;
        val := c_Variant_indet;
        val_ts_src := c_Timestamp_null;
        val_ts_srv := c_Timestamp_null;
        l_ncl <-- get_NodeClass(p_node);
        l_is_mandatory_attribute <-- local_is_mandatory_attribute(l_ncl, p_aid);
        IF l_is_mandatory_attribute = TRUE THEN
            IF l_ncl = e_ncl_Variable & p_aid = e_aid_Value THEN
                l_is_local_read <-- is_local_service_treatment;
                IF l_is_local_read = TRUE THEN
                    /* local read service call is always authorized */
                    sc, val, val_sc, val_ts_src, val_ts_srv <-- read_AddressSpace_Attribute_value(p_user, p_locales, p_node, p_nid, p_aid, p_index_range)
                ELSE
                    l_access_lvl <-- get_AccessLevel(p_node);
                    l_access_read <-- is_t_access_level_currentRead(l_access_lvl);
                    IF l_access_read = TRUE THEN
                        l_user_auth <-- get_user_authorization(e_operation_type_read, p_nid, p_aid, p_user);
                        IF l_user_auth = TRUE THEN
                            sc, val, val_sc, val_ts_src, val_ts_srv <-- read_AddressSpace_Attribute_value(p_user, p_locales, p_node, p_nid, p_aid, p_index_range)
                        ELSE
                            sc := e_sc_bad_user_access_denied
                        END
                    ELSE
                       sc := e_sc_bad_not_readable
                    END
                END
            ELSE
                /* If not a Variable Value, read is always authorized (no access rights) */
                sc, val, val_sc, val_ts_src, val_ts_srv <-- read_AddressSpace_Attribute_value(p_user, p_locales, p_node, p_nid, p_aid, p_index_range)
            END
        END
    END
    ;

    statusCode, node <-- check_nodeId_isValid(nodeid) =
    VAR
        l_isvalid
    IN
        statusCode := e_sc_ok;
        node := c_Node_indet;
        IF nodeid = c_NodeId_indet
        THEN
            statusCode := e_sc_bad_node_id_invalid
        ELSE
            l_isvalid, node <-- readall_AddressSpace_Node(nodeid);
            IF l_isvalid = FALSE
            THEN
                statusCode := e_sc_bad_node_id_unknown
            END
        END
    END
    ;

    btyp_ok, btyp_need_conv <-- read_variable_compat_type(p_dv_typ_nid, p_dv_vr, p_var_typ_nid, p_var_vr) =
    btyp_ok, btyp_need_conv <-- is_variable_compat_type(p_dv_typ_nid, p_dv_vr, p_var_typ_nid, p_var_vr)
END
